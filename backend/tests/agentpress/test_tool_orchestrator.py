import pytest
import pytest
import asyncio
import os
import shutil
import importlib
import sys
import json # Added import
from typing import Dict, Any, List

from backend.agentpress.tool import Tool, ToolResult, openapi_schema, xml_schema, XMLTagSchema, XMLNodeMapping
from backend.agentpress.tool_orchestrator import ToolOrchestrator, DEFAULT_PLUGINS_DIR as 실제_DEFAULT_PLUGINS_DIR

# --- Mock Tool Definition ---
class MockTool(Tool):
    PLUGIN_TOOL_ID = "TestMockTool"

    def __init__(self, an_arg: str = "default_val"):
        self.an_arg = an_arg
        super().__init__() # Important to call super for schema registration

    # In ToolOrchestrator, the tool_id is the one it's registered with, execution_id is generated by orchestrator.
    # The tool methods themselves don't call success/fail_response anymore.
    # They return raw data or raise exceptions. Orchestrator wraps it.

    @openapi_schema({
        "name": "mock_simple_method", # This name is important if get_openapi_schemas relies on it
        "description": "A simple mock method.",
        "parameters": {
            "type": "object",
            "properties": {"param1": {"type": "string"}},
            "required": ["param1"],
        },
    })
    async def simple_method(self, param1: str) -> Dict[str, Any]:
        if param1 == "raise_error":
            raise ValueError("Simulated error in simple_method")
        return {"result": f"param1 was {param1}", "arg_value": self.an_arg}

    @openapi_schema({
        "name": "mock_another_method",
        "description": "Another mock method.",
        "parameters": {
            "type": "object",
            "properties": {"num": {"type": "integer"}},
            "required": ["num"],
        },
    })
    async def another_method(self, num: int) -> Dict[str, Any]:
        return {"number_received": num * 2}

    @xml_schema(
        tag_name="mock-xml-tool",
        mappings=[
            {"param_name": "xml_param", "node_type": "attribute", "path": "."}
        ],
        example="<mock-xml-tool xml_param=\"test_value\" />"
    )
    async def xml_method(self, xml_param: str) -> Dict[str, Any]:
        return {"xml_result": f"xml_param was {xml_param}"}

# --- Test Fixtures ---
@pytest.fixture
def orchestrator():
    return ToolOrchestrator()

@pytest.fixture
def mock_tool_instance():
    return MockTool(an_arg="custom_arg_for_instance")

# Fixture to create a temporary plugin directory for testing
TEST_PLUGIN_DIR_NAME = "test_orchestrator_plugins"

@pytest.fixture(scope="function") # Use function scope to ensure clean dir for each test
def temp_plugin_dir(tmp_path_factory):
    # tmp_path_factory provides a session-scoped base temp directory.
    # Create a subdirectory for this specific test run's plugins.
    plugin_path_base = tmp_path_factory.mktemp(TEST_PLUGIN_DIR_NAME)

    # To make plugins importable, we need to ensure the structure allows it.
    # The ToolOrchestrator uses `backend.agentpress.plugins.<module_name>`.
    # For tests, we can create a similar structure or add temp_plugin_dir to sys.path.
    # Let's try adding to sys.path for simplicity in tests, and ensure unique module names.

    # Create backend/agentpress/plugins structure inside temp dir if orchestrator relies on it
    # For now, let's assume direct import from file_path works for tests if module name is unique
    # or that the orchestrator's module prefixing is robust.
    # The orchestrator's `load_tools_from_directory` forms module names like `backend.agentpress.plugins.X`.
    # This means `backend/agentpress/plugins` needs to be an actual path structure or sys.path needs adjustment.

    # For tests, we'll use a simpler module naming for direct import,
    # and adjust if the orchestrator's hardcoded prefix causes issues.
    # The current `ToolOrchestrator` uses `f"backend.agentpress.plugins.{filename[:-3]}"`.
    # This means the test plugins *must* be in a path that ends with `backend/agentpress/plugins/`.

    # Create the nested structure for the orchestrator's import logic
    nested_plugin_dir = plugin_path_base / "backend" / "agentpress" / "plugins"
    nested_plugin_dir.mkdir(parents=True, exist_ok=True)

    # Add the base temp directory (root of backend/agentpress/plugins structure) to sys.path
    # so that `import backend.agentpress.plugins.test_plugin_module` works.
    # The parent of "backend" should be in sys.path.
    sys.path.insert(0, str(plugin_path_base))

    yield nested_plugin_dir # This is where plugin files will be created

    # Teardown: remove from sys.path and directory will be cleaned by tmp_path_factory
    sys.path.pop(0)
    # shutil.rmtree(plugin_path_base) # tmp_path_factory handles this


# --- Test Cases ---

def test_register_tool_instance(orchestrator: ToolOrchestrator, mock_tool_instance: MockTool):
    orchestrator.register_tool(mock_tool_instance, tool_id="MyInstanceMockTool")
    assert "MyInstanceMockTool" in orchestrator.tools
    assert orchestrator.tools["MyInstanceMockTool"] == mock_tool_instance

def test_register_tool_instance_default_id(orchestrator: ToolOrchestrator, mock_tool_instance: MockTool):
    # MockTool has PLUGIN_TOOL_ID = "TestMockTool"
    orchestrator.register_tool(mock_tool_instance)
    assert MockTool.PLUGIN_TOOL_ID in orchestrator.tools
    assert orchestrator.tools[MockTool.PLUGIN_TOOL_ID] == mock_tool_instance

@pytest.mark.asyncio
async def test_execute_tool_success(orchestrator: ToolOrchestrator, mock_tool_instance: MockTool):
    orchestrator.register_tool(mock_tool_instance, tool_id="TestTool")
    result: ToolResult = await orchestrator.execute_tool(
        tool_id="TestTool",
        method_name="simple_method",
        params={"param1": "test_value"}
    )
    assert result.status == "completed"
    assert result.tool_id == "TestTool"
    # result.result is a JSON string, parse it for comparison
    assert json.loads(result.result) == {"result": "param1 was test_value", "arg_value": "custom_arg_for_instance"}
    assert result.error is None

@pytest.mark.asyncio
async def test_execute_tool_method_raises_error(orchestrator: ToolOrchestrator, mock_tool_instance: MockTool):
    orchestrator.register_tool(mock_tool_instance, tool_id="TestTool")
    result: ToolResult = await orchestrator.execute_tool(
        tool_id="TestTool",
        method_name="simple_method",
        params={"param1": "raise_error"}
    )
    assert result.status == "failed"
    assert result.tool_id == "TestTool"
    assert "Simulated error in simple_method" in result.error
    assert result.result is None

@pytest.mark.asyncio
async def test_execute_tool_not_found(orchestrator: ToolOrchestrator):
    result = await orchestrator.execute_tool("NonExistentTool", "any_method", {})
    assert result.status == "failed"
    assert "Tool with ID 'NonExistentTool' not found" in result.error

@pytest.mark.asyncio
async def test_execute_method_not_found(orchestrator: ToolOrchestrator, mock_tool_instance: MockTool):
    orchestrator.register_tool(mock_tool_instance, tool_id="TestTool")
    result = await orchestrator.execute_tool("TestTool", "non_existent_method", {})
    assert result.status == "failed"
    assert "Method 'non_existent_method' not found on tool 'TestTool'" in result.error

def test_get_openapi_schemas(orchestrator: ToolOrchestrator, mock_tool_instance: MockTool):
    orchestrator.register_tool(mock_tool_instance, tool_id="MyMockTool")
    schemas = orchestrator.get_openapi_schemas() # This is List[Dict]

    assert isinstance(schemas, list)
    assert len(schemas) == 2 # simple_method and another_method are decorated

    method_names_in_schema = [s['name'] for s in schemas]
    # Name format is tool_id__method_name
    assert "MyMockTool__simple_method" in method_names_in_schema
    assert "MyMockTool__another_method" in method_names_in_schema

    simple_method_schema = next(s for s in schemas if s['name'] == "MyMockTool__simple_method")
    assert simple_method_schema['description'] == "A simple mock method."

def test_get_xml_examples(orchestrator: ToolOrchestrator, mock_tool_instance: MockTool):
    orchestrator.register_tool(mock_tool_instance, tool_id="MyMockTool")
    examples = orchestrator.get_xml_examples() # This is Dict[str, str]

    assert isinstance(examples, dict)
    assert "mock-xml-tool" in examples
    assert examples["mock-xml-tool"] == "<mock-xml-tool xml_param=\"test_value\" />"

# --- Plugin Loading Tests ---

PLUGIN_FILE_CONTENT_VALID = """
from backend.agentpress.tool import Tool, openapi_schema

class PluginLoadedTool(Tool):
    PLUGIN_TOOL_ID = "MyPluginTool1"

    @openapi_schema({"name": "plugin_method_one", "description": "Method one from plugin"})
    async def method_one(self, text: str) -> dict:
        return {"received": text}

class AnotherInPlugin(Tool):
    # No PLUGIN_TOOL_ID, uses class name
    @openapi_schema({"name": "another_plugin_method", "description": "Another method"})
    async def another_method(self) -> dict:
        return {"status": "ok"}
"""

PLUGIN_FILE_CONTENT_MODIFIED = """
from backend.agentpress.tool import Tool, openapi_schema

class PluginLoadedTool(Tool): # Same class name, same PLUGIN_TOOL_ID
    PLUGIN_TOOL_ID = "MyPluginTool1"

    @openapi_schema({"name": "plugin_method_one", "description": "MODIFIED Method one from plugin"}) # Changed description
    async def method_one(self, text: str) -> dict: # Same method
        return {"received": text, "version": 2} # Changed return

class NewToolInReload(Tool):
    PLUGIN_TOOL_ID = "NewAfterReload"
    @openapi_schema({"name": "new_method_after_reload", "description": "A brand new method"})
    async def new_method(self) -> dict:
        return {"reloaded_new": True}

"""

PLUGIN_FILE_NO_TOOLS = """
# This plugin has no Tool subclasses
MY_CONSTANT = 123
def some_function():
    return "hello"
"""

PLUGIN_FILE_INSTANTIATION_ERROR = """
from backend.agentpress.tool import Tool
class BadInitTool(Tool):
    PLUGIN_TOOL_ID = "BadInit"
    def __init__(self, required_arg: str): # Requires an argument
        self.required_arg = required_arg
    async def some_method(self): return {}
"""


def test_load_tools_from_directory(orchestrator: ToolOrchestrator, temp_plugin_dir: str):
    plugin_file_path = os.path.join(temp_plugin_dir, "test_plugin_module_1.py")
    with open(plugin_file_path, "w") as f:
        f.write(PLUGIN_FILE_CONTENT_VALID)

    # Create another file with no tools
    no_tools_path = os.path.join(temp_plugin_dir, "no_tools_plugin.py")
    with open(no_tools_path, "w") as f:
        f.write(PLUGIN_FILE_NO_TOOLS)

    # Create a file that will cause an instantiation error
    bad_init_path = os.path.join(temp_plugin_dir, "bad_init_plugin.py")
    with open(bad_init_path, "w") as f:
        f.write(PLUGIN_FILE_INSTANTIATION_ERROR)

    # The orchestrator expects to load from a path like `backend/agentpress/plugins`
    # temp_plugin_dir is already structured like `.../backend/agentpress/plugins`
    orchestrator.load_tools_from_directory(str(temp_plugin_dir))

    assert "MyPluginTool1" in orchestrator.tools
    assert isinstance(orchestrator.tools["MyPluginTool1"], Tool)
    assert orchestrator.tools["MyPluginTool1"].__class__.__name__ == "PluginLoadedTool"

    assert "AnotherInPlugin" in orchestrator.tools # Uses class name as ID
    assert isinstance(orchestrator.tools["AnotherInPlugin"], Tool)

    assert "BadInit" not in orchestrator.tools # Should fail to instantiate
    assert len(orchestrator.tools) == 2 # Only two tools should be loaded

    # Check plugin_sources
    assert orchestrator.plugin_sources["MyPluginTool1"] == plugin_file_path
    assert orchestrator.plugin_sources["AnotherInPlugin"] == plugin_file_path


def test_load_tools_from_non_existent_directory(orchestrator: ToolOrchestrator, caplog):
    orchestrator.load_tools_from_directory("non_existent_dir_for_plugins")
    assert "Plugin directory 'non_existent_dir_for_plugins' not found" in caplog.text
    assert not orchestrator.tools


def test_unload_tool(orchestrator: ToolOrchestrator, temp_plugin_dir: str):
    plugin_file_path = os.path.join(temp_plugin_dir, "test_plugin_to_unload.py")
    with open(plugin_file_path, "w") as f:
        f.write(PLUGIN_FILE_CONTENT_VALID)

    orchestrator.load_tools_from_directory(str(temp_plugin_dir))
    assert "MyPluginTool1" in orchestrator.tools
    assert "MyPluginTool1" in orchestrator.plugin_sources

    orchestrator.unload_tool("MyPluginTool1")
    assert "MyPluginTool1" not in orchestrator.tools
    assert "MyPluginTool1" not in orchestrator.plugin_sources

    # Unloading non-existent tool should not error
    orchestrator.unload_tool("NonExistentToolForUnload")


@pytest.mark.asyncio
async def test_reload_tool(orchestrator: ToolOrchestrator, temp_plugin_dir: str):
    plugin_file_path = os.path.join(temp_plugin_dir, "test_plugin_to_reload.py")
    with open(plugin_file_path, "w") as f:
        f.write(PLUGIN_FILE_CONTENT_VALID) # Initial content

    orchestrator.load_tools_from_directory(str(temp_plugin_dir))
    assert "MyPluginTool1" in orchestrator.tools
    original_tool_instance = orchestrator.tools["MyPluginTool1"]

    # Check initial description from schema
    schemas_before = orchestrator.get_tool_schemas_for_llm()
    schema_before = next(s for s in schemas_before if s['name'] == "MyPluginTool1__method_one")
    assert schema_before['description'] == "Method one from plugin"

    # Modify the plugin file on disk
    with open(plugin_file_path, "w") as f:
        f.write(PLUGIN_FILE_CONTENT_MODIFIED)

    # Ensure module name matches how load_tools_from_directory would create it
    module_name = f"backend.agentpress.plugins.test_plugin_to_reload"
    if module_name in sys.modules: # Clean up if already imported by a previous test in same session (unlikely with tmp_path)
        del sys.modules[module_name]

    reload_success = orchestrator.reload_tool("MyPluginTool1")
    assert reload_success
    assert "MyPluginTool1" in orchestrator.tools
    reloaded_tool_instance = orchestrator.tools["MyPluginTool1"]
    assert reloaded_tool_instance is not original_tool_instance # Should be a new instance

    # Check if description changed in schema
    schemas_after = orchestrator.get_tool_schemas_for_llm()
    schema_after = next(s for s in schemas_after if s['name'] == "MyPluginTool1__method_one")
    assert schema_after['description'] == "MODIFIED Method one from plugin"

    # Check that the new tool from the modified file IS NOT loaded,
    # as reload_tool currently only reloads the specified tool_id's class.
    assert "NewAfterReload" not in orchestrator.tools
    # assert isinstance(orchestrator.tools["NewAfterReload"], Tool) # This would fail

    # Test executing a method from the reloaded tool
    result: ToolResult = await orchestrator.execute_tool(
        tool_id="MyPluginTool1",
        method_name="method_one", # Actual method name, not schema name
        params={"text": "after_reload"}
    )
    assert result.status == "completed"
    assert json.loads(result.result) == {"received": "after_reload", "version": 2} # Used json.loads()

def test_reload_tool_not_from_plugin(orchestrator: ToolOrchestrator, mock_tool_instance: MockTool):
    orchestrator.register_tool(mock_tool_instance, tool_id="DirectTool") # Registered directly
    assert not orchestrator.reload_tool("DirectTool")

def test_reload_tool_file_deleted(orchestrator: ToolOrchestrator, temp_plugin_dir: str):
    plugin_file_path = os.path.join(temp_plugin_dir, "test_plugin_file_to_delete.py")
    with open(plugin_file_path, "w") as f:
        f.write(PLUGIN_FILE_CONTENT_VALID)

    orchestrator.load_tools_from_directory(str(temp_plugin_dir))
    assert "MyPluginTool1" in orchestrator.tools

    os.remove(plugin_file_path) # Delete the plugin file

    reload_success = orchestrator.reload_tool("MyPluginTool1")
    assert not reload_success # Reload should fail as file is gone
    assert "MyPluginTool1" not in orchestrator.tools # Should be unloaded


# Note: The current ToolOrchestrator.reload_tool has a specific way of forming module names.
# The temp_plugin_dir fixture is set up to match this by creating the nested path:
# `tmp_path_factory_root / "test_orchestrator_pluginsX" / "backend" / "agentpress" / "plugins"`
# and adding `tmp_path_factory_root / "test_orchestrator_pluginsX"` to sys.path.
# This allows imports like `backend.agentpress.plugins.test_plugin_module_1` to work.

# Actual DEFAULT_PLUGINS_DIR for the application is "backend/agentpress/plugins"
# The tests use a temporary, isolated directory structured to mimic this for reliable testing.
