from typing import List, Optional, Dict, Any
import json
from datetime import datetime, timezone # Added
# Removed APIError import
from services.supabase import DBConnection
from agentpress.task_types import TaskState, TaskStorage
from utils.logger import logger

class SupabaseTaskStorage(TaskStorage):
    """
    Supabase implementation for TaskStorage.
    Persists tasks in a Supabase PostgreSQL database.
    """

    def __init__(self, db_connection: Optional[DBConnection] = None):
        self.db_connection = db_connection if db_connection else DBConnection()
        self._table_name = "tasks"
        logger.info("SupabaseTaskStorage initialized.")

    def _to_db_format(self, task: TaskState) -> Dict[str, Any]:
        """Converts TaskState object to a dictionary suitable for Supabase."""
        db_dict = task.__dict__.copy()
        # JSONB fields need to be dumped if they are complex objects,
        # though Supabase client might handle dicts for JSONB automatically.
        # Ensuring they are JSON strings if that's preferred or causes issues.
        for field in ["subtasks", "dependencies", "assignedTools", "artifacts", "metadata", "result"]:
            if field in db_dict and db_dict[field] is not None:
                # The client should handle Python dicts to JSONB correctly.
                # If direct dicts cause issues, uncomment json.dumps:
                # db_dict[field] = json.dumps(db_dict[field])
                pass

        # Convert numerical timestamps (floats) to ISO 8601 strings for Supabase
        if 'startTime' in db_dict and isinstance(db_dict['startTime'], (int, float)):
            dt_object = datetime.fromtimestamp(db_dict['startTime'], timezone.utc)
            db_dict['startTime'] = dt_object.isoformat()

        if 'endTime' in db_dict and db_dict['endTime'] is not None:
            if isinstance(db_dict['endTime'], (int, float)):
                dt_object = datetime.fromtimestamp(db_dict['endTime'], timezone.utc)
                db_dict['endTime'] = dt_object.isoformat()
        elif 'endTime' in db_dict and db_dict['endTime'] is None:
            # Ensure None is passed as null if the field exists and is None
            db_dict['endTime'] = None

        return db_dict

    def _from_db_format(self, data: Dict[str, Any]) -> TaskState:
        """Converts a dictionary from Supabase to a TaskState object."""
        # Create a mutable copy for modifications
        task_data = data.copy()

        # Convert ISO 8601 string timestamps from Supabase back to float Unix timestamps
        raw_start_time = task_data.get('startTime')
        if isinstance(raw_start_time, str):
            try:
                # Handle both 'Z' and '+00:00' if Supabase returns varying formats
                iso_time_str = raw_start_time.replace('Z', '+00:00')
                task_data['startTime'] = datetime.fromisoformat(iso_time_str).timestamp()
            except ValueError as e:
                logger.error(f"Error parsing startTime '{raw_start_time}': {e}")
                task_data['startTime'] = 0.0 # Fallback or raise error
        elif isinstance(raw_start_time, (int, float)): # If it's already a number
             task_data['startTime'] = float(raw_start_time)
        # If it's None or other types, TaskState default_factory for startTime should handle it or raise error if not Optional

        raw_end_time = task_data.get('endTime')
        if isinstance(raw_end_time, str):
            try:
                iso_time_str = raw_end_time.replace('Z', '+00:00')
                task_data['endTime'] = datetime.fromisoformat(iso_time_str).timestamp()
            except ValueError as e:
                logger.error(f"Error parsing endTime '{raw_end_time}': {e}")
                task_data['endTime'] = None # Fallback or raise error
        elif isinstance(raw_end_time, (int, float)): # If it's already a number
             task_data['endTime'] = float(raw_end_time)
        else: # Handles None or if field is missing
            task_data['endTime'] = None

        # Ensure other JSONB fields are parsed if they are strings (though client usually handles this)
        # for field in ["subtasks", "dependencies", "assignedTools", "artifacts", "metadata", "result"]:
        #     if field in task_data and isinstance(task_data[field], str):
        #         try:
        #             task_data[field] = json.loads(task_data[field])
        #         except json.JSONDecodeError:
        #             logger.warning(f"Failed to parse JSON string for field {field} in task {task_data.get('id')}")

        # Remove fields that are in the DB but not part of TaskState constructor,
        # or are auto-generated by DB and should not be passed to TaskState directly if they cause issues.
        task_data.pop('created_at', None)
        task_data.pop('updated_at', None)

        return TaskState(**task_data)


    async def save_task(self, task: TaskState) -> None:
        """Saves or updates a task in Supabase."""
        client = await self.db_connection.client
        task_dict = self._to_db_format(task)

        try:
            # Upsert operation: inserts if id doesn't exist, updates if it does.
            # 'id' is the primary key and should be used for conflict resolution.
            response = await client.table(self._table_name).upsert(task_dict).execute()
            # Assuming execute() raises an exception on error, response.data should be valid if no exception.
            if response.data:
                logger.info(f"Task {task.id} saved/updated successfully.")
            else:
                # This case might indicate an issue with RLS or if upsert doesn't return data by default
                # depending on preference settings (e.g. return="minimal").
                # If data is critical, this might need specific handling or ensuring preferences demand data.
                logger.warning(f"Supabase upsert for task {task.id} returned no data. Response: {response}")
        except Exception as e: # Changed from APIError to Exception
            logger.error(f"Supabase client operation failed with error type: {type(e).__name__} - {e}", exc_info=True)
            raise # Re-raise other errors

    async def load_task(self, task_id: str) -> Optional[TaskState]:
        """Loads a specific task by its ID from Supabase."""
        client = await self.db_connection.client
        try:
            response = await client.table(self._table_name).select("*").eq("id", task_id).maybe_single().execute()
            if response.data:
                return self._from_db_format(response.data)
            # No data and no error from maybe_single() means task not found.
            return None
        except Exception as e: # Changed from APIError to Exception
            logger.error(f"Supabase client operation failed with error type: {type(e).__name__} - {e}", exc_info=True)
            raise

    async def load_all_tasks(self) -> List[TaskState]:
        """Loads all tasks from Supabase."""
        client = await self.db_connection.client
        try:
            response = await client.table(self._table_name).select("*").execute()
            if response.data:
                return [self._from_db_format(item) for item in response.data]
            # If no data and no error, it's an empty list, not an error.
            return []
        except Exception as e: # Changed from APIError to Exception
            logger.error(f"Supabase client operation failed with error type: {type(e).__name__} - {e}", exc_info=True)
            raise

    async def delete_task(self, task_id: str) -> None:
        """Deletes a task by its ID from Supabase."""
        client = await self.db_connection.client
        try:
            # Delete operation: execute() will raise an error if deletion fails.
            # Successful deletion might not return data, depending on Supabase settings (e.g. return="minimal").
            await client.table(self._table_name).delete().eq("id", task_id).execute()
            # If execute() does not raise, assume success.
            logger.info(f"Task {task_id} deleted (or did not exist).")
        except Exception as e: # Changed from APIError to Exception
            logger.error(f"Supabase client operation failed with error type: {type(e).__name__} - {e}", exc_info=True)
            raise

    async def update_task(self, task_id: str, updates: Dict[str, Any]) -> Optional[TaskState]:
        """
        Atomically updates a task in Supabase using its update method.
        Note: This assumes 'updates' contains keys that match column names.
        The TaskState dataclass field names (camelCase for some) need to match DB column names (snake_case or quoted camelCase).
        The migration used quoted camelCase for "startTime", "endTime", "parentId", "assignedTools".
        """
        client = await self.db_connection.client

        # Ensure endTime is handled correctly based on status
        if updates.get("status") in ["completed", "failed", "cancelled"] and "endTime" not in updates:
            updates["endTime"] = DBConnection.now_iso() # Use DBConnection helper for consistent time

        # The keys in 'updates' must match the database column names.
        # If TaskState uses camelCase and DB uses snake_case, mapping is needed here
        # or ensure DB columns match TaskState fields (migration uses quoted camelCase for some).
        # For this implementation, we assume `updates` keys are already correct for the DB.

        db_updates = updates.copy()

        # Ensure JSONB fields are correctly formatted if necessary, though client usually handles dicts.
        # for field in ["subtasks", "dependencies", "assignedTools", "artifacts", "metadata", "result"]:
        #     if field in db_updates and isinstance(db_updates[field], (list, dict)):
        #         db_updates[field] = json.dumps(db_updates[field])

        try:
            response = await client.table(self._table_name).update(db_updates).eq("id", task_id).execute()
            if response.data:
                logger.info(f"Task {task_id} updated via Supabase direct update.")
                return self._from_db_format(response.data[0]) # Assuming update returns the updated record
            else:
                # This could happen if the task_id doesn't exist or RLS prevents viewing.
                # Or if PostgREST preference is `return=minimal`.
                logger.warning(f"Update for task {task_id} returned no data. Task may not exist or check PostgREST preferences.")
                return None
        except Exception as e: # Changed from APIError to Exception
            logger.error(f"Supabase client operation failed with error type: {type(e).__name__} - {e}", exc_info=True)
            raise

    async def get_tasks_by_status(self, status: str) -> List[TaskState]:
        """Loads all tasks with a specific status."""
        client = await self.db_connection.client
        try:
            response = await client.table(self._table_name).select("*").eq("status", status).execute()
            if response.data:
                return [self._from_db_format(item) for item in response.data]
            return [] # No tasks found with this status
        except Exception as e: # Changed from APIError to Exception
            logger.error(f"Supabase client operation failed with error type: {type(e).__name__} - {e}", exc_info=True)
            raise

    async def get_subtasks(self, parent_id: str) -> List[TaskState]:
        """Loads all subtasks for a given parent ID."""
        client = await self.db_connection.client
        try:
            response = await client.table(self._table_name).select("*").eq("parentId", parent_id).execute()
            if response.data:
                return [self._from_db_format(item) for item in response.data]
            return [] # No subtasks found for this parent
        except Exception as e: # Changed from APIError to Exception
            logger.error(f"Supabase client operation failed with error type: {type(e).__name__} - {e}", exc_info=True)
            raise
