# scripts/generate_ts_types.py
import os
import subprocess
import sys

def main():
    # Define paths
    # Assume this script is in a top-level 'scripts' directory
    scripts_dir = os.path.dirname(os.path.abspath(__file__))
    project_root_dir = os.path.abspath(os.path.join(scripts_dir, '..'))

    pydantic_models_module_path = 'backend.agentpress.api_models_tasks' # Python importable path
    # For pydantic-to-typescript, it's often easier to give it the file path directly
    # if the module structure is complex or not easily runnable from where the tool is called.
    # However, the --module argument expects a Python module path.
    # Let's construct the file path for existence checks and for the tool if needed.
    pydantic_models_file = os.path.join(project_root_dir, 'backend', 'agentpress', 'api_models_tasks.py')
    typescript_output_file = os.path.join(project_root_dir, 'frontend', 'src', 'types', 'tasks.ts')

    # Ensure the Pydantic models file exists
    if not os.path.exists(pydantic_models_file):
        print(f"Error: Pydantic models file not found at {pydantic_models_file}")
        sys.exit(1)

    # Ensure the output directory exists
    os.makedirs(os.path.dirname(typescript_output_file), exist_ok=True)

    print(f"Attempting to generate TypeScript types from Python models in {pydantic_models_module_path} (file: {pydantic_models_file})")
    print(f"Output TypeScript file will be: {typescript_output_file}")

    try:
        # Command to run pydantic-to-typescript
        # The module path should be importable from the current working directory,
        # or pydantic-to-typescript should be run from a directory where it can import the module.
        # Running from project_root_dir is a common setup.
        command = [
            "pydantic-to-typescript",
            "--module", pydantic_models_module_path, # Use Python module path
            "--output", typescript_output_file,
            # Add --strict-optional if you want optional fields to be `field?: type` vs `field: type | null`
            # Add --enums-to-unions if you prefer string literal unions for Enums
        ]

        # For pydantic-to-typescript to correctly import the module,
        # it's best to run this command from the project root directory.
        # The subprocess will inherit Python environment, but PYTHONPATH might need to be considered.
        # Setting PYTHONPATH explicitly can help.
        env = os.environ.copy()
        if 'PYTHONPATH' in env:
            env['PYTHONPATH'] = project_root_dir + os.pathsep + env['PYTHONPATH']
        else:
            env['PYTHONPATH'] = project_root_dir

        print(f"Running command: {' '.join(command)}")
        print(f"From directory: {project_root_dir}")
        print(f"With PYTHONPATH: {env.get('PYTHONPATH')}")


        # Using cwd=project_root_dir so that pydantic-to-typescript can find the module
        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=project_root_dir, env=env)
        stdout, stderr = process.communicate()

        if process.returncode == 0:
            print("\nTypeScript types generated successfully.")

            # Prepend a "do not edit" header
            try:
                with open(typescript_output_file, 'r+') as f:
                    content = f.read()
                    f.seek(0, 0)
                    f.write("// Generated by pydantic-to-typescript. Do not edit manually.\n"
                            "// To regenerate, run `poetry run generate-types` or `python scripts/generate_ts_types.py`\n\n" + content)
                print(f"Successfully added header to {typescript_output_file}")
            except Exception as e_header:
                print(f"Warning: Could not add header to generated file: {e_header}")

            print("\nPlease review the generated file and commit the changes if they are correct.")
            if stdout:
                print("STDOUT:\n", stdout.decode())
            if stderr: # pydantic-to-typescript sometimes outputs info to stderr
                print("STDERR (may contain info/warnings):\n", stderr.decode())

        else:
            print("\nError generating TypeScript types:")
            if stdout:
                print("STDOUT:\n", stdout.decode())
            if stderr:
                print("STDERR:\n", stderr.decode())
            sys.exit(1)

    except FileNotFoundError:
        print("Error: pydantic-to-typescript command not found. Make sure it's installed and in your PATH (or Python environment).")
        print("You might need to run `poetry install --group dev` or `pip install pydantic-to-typescript`.")
        sys.exit(1)
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
